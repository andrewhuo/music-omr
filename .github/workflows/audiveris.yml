name: Audiveris OMR + Measure Label Debug

on:
  workflow_dispatch:
    inputs:
      pdf_gcs_uri:
        description: "GCS URI to input PDF (gs://music-omr-bucket-777135743132/input/test.pdf)"
        required: true
        type: string
      audiveris_image:
        description: "Pinned Audiveris image digest (ghcr.io/<owner>/audiveris-engine@sha256:...)"
        required: false
        default: "ghcr.io/REPLACE_WITH_OWNER/audiveris-engine@sha256:REPLACE_WITH_REAL_DIGEST"
        type: string
      enable_page_split_manifest:
        description: "Enable strict per-page XML manifest mode (split PDF and run Audiveris per page)"
        required: false
        default: false
        type: boolean

jobs:
  pipeline:
    runs-on: ubuntu-latest
    env:
      OUTPUT_PREFIX: "gs://music-omr-bucket-777135743132/output"

    permissions:
      contents: read
      id-token: write

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT_EMAIL }}
          create_credentials_file: true

      - name: Set up Google Cloud SDK (apt)
        run: |
          set -euo pipefail
          if command -v gcloud >/dev/null 2>&1; then
            gcloud --version
            exit 0
          fi
          sudo apt-get update -y
          sudo apt-get install -y apt-transport-https ca-certificates gnupg curl
          curl -fsSL https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo gpg --dearmor -o /usr/share/keyrings/cloud.google.gpg
          echo "deb [signed-by=/usr/share/keyrings/cloud.google.gpg] https://packages.cloud.google.com/apt cloud-sdk main" | sudo tee /etc/apt/sources.list.d/google-cloud-sdk.list
          sudo apt-get update -y
          sudo apt-get install -y google-cloud-cli
          gcloud --version

      - name: Configure gcloud auth for gsutil
        run: |
          set -euo pipefail
          if [[ -z "${GOOGLE_APPLICATION_CREDENTIALS:-}" ]]; then
            echo "ERROR: GOOGLE_APPLICATION_CREDENTIALS not set"
            exit 1
          fi
          echo "GOOGLE_APPLICATION_CREDENTIALS=${GOOGLE_APPLICATION_CREDENTIALS}"
          echo "CLOUDSDK_AUTH_CREDENTIAL_FILE_OVERRIDE=${GOOGLE_APPLICATION_CREDENTIALS}" >> "$GITHUB_ENV"
          gcloud auth login --cred-file="${GOOGLE_APPLICATION_CREDENTIALS}"
          gcloud auth list

      - name: Show run context
        run: |
          set -euo pipefail
          echo "repo: $GITHUB_REPOSITORY"
          echo "sha:  $GITHUB_SHA"
          echo "pdf_gcs_uri: ${{ inputs.pdf_gcs_uri }}"
          echo "audiveris_image: ${{ inputs.audiveris_image }}"
          echo "enable_page_split_manifest: ${{ inputs.enable_page_split_manifest }}"
          echo "output_prefix: ${OUTPUT_PREFIX}"

      - name: Download input PDF
        run: |
          set -euo pipefail
          mkdir -p /tmp/work
          gsutil cp "${{ inputs.pdf_gcs_uri }}" /tmp/work/input.pdf
          ls -lh /tmp/work/input.pdf

      - name: Run Audiveris OMR
        run: |
          set -euo pipefail
          mkdir -p /tmp/work
          mkdir -p /tmp/work/.cache /tmp/work/.config /tmp/work/tmp
          AUDIVERIS_IMAGE="${{ inputs.audiveris_image }}"
          echo "WORKFLOW_SIGNATURE=engine-pin-v1"
          echo "WORKFLOW_SHA=${GITHUB_SHA}"
          echo "AUDIVERIS_IMAGE=${AUDIVERIS_IMAGE}"

          if [[ -z "${AUDIVERIS_IMAGE}" ]]; then
            echo "ERROR: audiveris_image input is empty"
            exit 1
          fi
          if [[ "${AUDIVERIS_IMAGE}" == *"REPLACE_WITH_REAL_DIGEST"* ]] || [[ "${AUDIVERIS_IMAGE}" == *"REPLACE_WITH_OWNER"* ]]; then
            echo "ERROR: audiveris_image is still placeholder text. Set a real GHCR digest."
            exit 1
          fi
          if [[ "${AUDIVERIS_IMAGE}" != *@sha256:* ]]; then
            echo "ERROR: audiveris_image must be pinned by digest using @sha256:"
            exit 1
          fi
          echo "PULLING_AUDIVERIS_IMAGE=${AUDIVERIS_IMAGE}"
          docker pull "${AUDIVERIS_IMAGE}"
          echo "AUDIVERIS_IMAGE_ID=$(docker image inspect "${AUDIVERIS_IMAGE}" --format '{{.Id}}')"
          echo "AUDIVERIS_IMAGE_REPODIGESTS=$(docker image inspect "${AUDIVERIS_IMAGE}" --format '{{json .RepoDigests}}')"

          probe_omr_version() {
            local image="$1"
            local required="5.9.0"
            docker run --rm \
              --user "$(id -u):$(id -g)" \
              -v /tmp/work:/work \
              -e HOME="/work" \
              -e XDG_CACHE_HOME="/work/.cache" \
              -e XDG_CONFIG_HOME="/work/.config" \
              -e JAVA_TOOL_OPTIONS="-Duser.home=/work -Djava.io.tmpdir=/work/tmp" \
              "$image" \
              sh -c 'set -e; AUDI_BIN="/audiveris-extract/bin/Audiveris"; if [ -x /audiveris/bin/Audiveris ]; then AUDI_BIN="/audiveris/bin/Audiveris"; fi; if [ -x /opt/audiveris/bin/Audiveris ]; then AUDI_BIN="/opt/audiveris/bin/Audiveris"; fi; mkdir -p /work/.cache /work/.config /work/tmp; "$AUDI_BIN" -help >/work/audi_help_probe.txt 2>&1 || true;'

            local version_raw
            version_raw="$(grep -Eo '([0-9]+\.[0-9]+\.[0-9]+([-.:][A-Za-z0-9]+)?)' /tmp/work/audi_help_probe.txt | head -n 1 || true)"
            local version_num
            version_num="$(grep -Eo '[0-9]+\.[0-9]+\.[0-9]+' /tmp/work/audi_help_probe.txt | head -n 1 || true)"

            echo "AUDIVERIS_VERSION_RAW=${version_raw}"
            echo "AUDIVERIS_VERSION_NUM=${version_num}"

            if [[ -z "${version_num}" ]]; then
              echo "ERROR: unable to detect Audiveris version from -help output"
              tail -n 120 /tmp/work/audi_help_probe.txt || true
              exit 1
            fi
            echo "AUDIVERIS_HELP_PROBE_HEAD_BEGIN"
            sed -n '1,80p' /tmp/work/audi_help_probe.txt || true
            echo "AUDIVERIS_HELP_PROBE_HEAD_END"

            if [[ "$(printf '%s\n%s\n' "${required}" "${version_num}" | sort -V | head -n 1)" != "${required}" ]]; then
              echo "ERROR: Audiveris version ${version_num} is below required ${required}"
              exit 1
            fi
          }

          run_omr() {
            local image="$1"
            local out_dir_name="$2"
            docker run --rm \
              --user "$(id -u):$(id -g)" \
              -v /tmp/work:/work \
              -e AUDI_IMAGE="${image}" \
              -e AUDI_OUT_DIR="/work/${out_dir_name}" \
              -e HOME="/work" \
              -e XDG_CACHE_HOME="/work/.cache" \
              -e XDG_CONFIG_HOME="/work/.config" \
              -e JAVA_TOOL_OPTIONS="-Duser.home=/work -Djava.io.tmpdir=/work/tmp" \
              "$image" \
              sh -c 'set -e; AUDI_BIN="/audiveris-extract/bin/Audiveris"; if [ -x /audiveris/bin/Audiveris ]; then AUDI_BIN="/audiveris/bin/Audiveris"; fi; if [ -x /opt/audiveris/bin/Audiveris ]; then AUDI_BIN="/opt/audiveris/bin/Audiveris"; fi; mkdir -p /work/.cache /work/.config /work/tmp; echo "AUDIVERIS_ATTEMPT image=${AUDI_IMAGE} out_dir=${AUDI_OUT_DIR} bin=${AUDI_BIN} HOME=${HOME} XDG_CACHE_HOME=${XDG_CACHE_HOME}"; "$AUDI_BIN" -help >/work/audi_help.txt 2>&1 || true; if grep -Eq "AccessDeniedException: /\\.cache|Loader\\.getCacheDir\\(\\).*null|ExceptionInInitializerError" /work/audi_help.txt; then echo "AUDIVERIS_PREFLIGHT_ERROR"; tail -n 120 /work/audi_help.txt || true; exit 86; fi; "$AUDI_BIN" -batch -export -output "$AUDI_OUT_DIR" /work/input.pdf'
          }

          run_omr_smoke() {
            local image="$1"
            local out_dir_name="$2"
            docker run --rm \
              --user "$(id -u):$(id -g)" \
              -v /tmp/work:/work \
              -e AUDI_IMAGE="${image}" \
              -e AUDI_OUT_DIR="/work/${out_dir_name}" \
              -e HOME="/work" \
              -e XDG_CACHE_HOME="/work/.cache" \
              -e XDG_CONFIG_HOME="/work/.config" \
              -e JAVA_TOOL_OPTIONS="-Duser.home=/work -Djava.io.tmpdir=/work/tmp" \
              "$image" \
              sh -c 'set -e; AUDI_BIN="/audiveris-extract/bin/Audiveris"; if [ -x /audiveris/bin/Audiveris ]; then AUDI_BIN="/audiveris/bin/Audiveris"; fi; if [ -x /opt/audiveris/bin/Audiveris ]; then AUDI_BIN="/opt/audiveris/bin/Audiveris"; fi; mkdir -p /work/.cache /work/.config /work/tmp; echo "AUDIVERIS_SMOKE image=${AUDI_IMAGE} out_dir=${AUDI_OUT_DIR} bin=${AUDI_BIN}"; "$AUDI_BIN" -batch -export -output "$AUDI_OUT_DIR" -sheets 1 /work/input.pdf'
          }

          check_mxl() {
            local out_dir="$1"
            local context="${2:-unknown}"
            python - "$out_dir" "$context" <<'PY'
          import glob
          import os
          import re
          import sys
          import zipfile
          import xml.etree.ElementTree as ET

          try:
              from lxml import etree as LET  # type: ignore
          except Exception:
              LET = None


          def local(tag):
              if isinstance(tag, str):
                  return tag.split("}", 1)[-1] if "}" in tag else tag
              return str(tag)


          def count_by_tagscan(raw: bytes):
              parts = len(re.findall(br"<\s*part(\s|>)", raw, flags=re.IGNORECASE))
              measures = len(re.findall(br"<\s*measure(\s|>)", raw, flags=re.IGNORECASE))
              return parts, measures


          def score_xml_member(raw: bytes):
              try:
                  root = ET.fromstring(raw)
                  parts = sum(1 for el in root.iter() if local(el.tag) == "part")
                  measures = sum(1 for el in root.iter() if local(el.tag) == "measure")
                  return {
                      "parse": "stdlib",
                      "root": local(root.tag),
                      "parts": parts,
                      "measures": measures,
                  }
              except Exception:
                  pass

              if LET is not None:
                  try:
                      parser = LET.XMLParser(recover=True, huge_tree=True)
                      root = LET.fromstring(raw, parser=parser)
                      root_name = local(root.tag) if root is not None else "unknown"
                      parts = len(root.xpath('//*[local-name()="part"]')) if root is not None else 0
                      measures = len(root.xpath('//*[local-name()="measure"]')) if root is not None else 0
                      return {
                          "parse": "lxml_recover",
                          "root": root_name,
                          "parts": parts,
                          "measures": measures,
                      }
                  except Exception:
                      pass

              parts, measures = count_by_tagscan(raw)
              return {
                  "parse": "tagscan",
                  "root": "unknown",
                  "parts": parts,
                  "measures": measures,
              }


          def score_mxl(mxl_path):
              best_member = None
              try:
                  with zipfile.ZipFile(mxl_path, "r") as z:
                      for name in z.namelist():
                          if name.startswith("META-INF/"):
                              continue
                          if not (name.lower().endswith(".xml") or name.lower().endswith(".musicxml")):
                              continue
                          try:
                              raw = z.read(name)
                          except Exception:
                              continue
                          scored = score_xml_member(raw)
                          cand = {"member": name, **scored}
                          if best_member is None or (cand["measures"], cand["parts"]) > (
                              best_member["measures"],
                              best_member["parts"],
                          ):
                              best_member = cand
              except Exception as exc:
                  return {
                      "path": mxl_path,
                      "member": None,
                      "parse": "zip_error",
                      "root": "zip_error",
                      "parts": 0,
                      "measures": 0,
                      "error": str(exc),
                  }

              if best_member is None:
                  return {
                      "path": mxl_path,
                      "member": None,
                      "parse": "none",
                      "root": "no_xml_members",
                      "parts": 0,
                      "measures": 0,
                      "error": None,
                  }

              return {"path": mxl_path, **best_member, "error": None}


          out_dir = sys.argv[1]
          context = sys.argv[2]
          mxl_candidates = sorted(glob.glob(os.path.join(out_dir, "input", "*.mxl")))
          print(f"MXL_CHECK_CONTEXT context={context} out_dir={out_dir} candidate_count={len(mxl_candidates)}")
          if not mxl_candidates:
              print(f"MXL_CHECK_FAIL context={context} reason=no_mxl_files out_dir={out_dir}")
              raise SystemExit(2)

          scored = [score_mxl(path) for path in mxl_candidates]
          for row in scored:
              err = f" error={row['error']}" if row.get("error") else ""
              print(
                  "MXL_CANDIDATE "
                  f"context={context} path={row['path']} member={row['member']} parse={row['parse']} "
                  f"root={row['root']} parts={row['parts']} measures={row['measures']}{err}"
              )

          best = max(scored, key=lambda r: (r["measures"], r["parts"]))
          print(
              "MXL_SELECTED "
              f"context={context} path={best['path']} member={best['member']} parse={best['parse']} "
              f"parts={best['parts']} measures={best['measures']}"
          )

          with open(f"/tmp/work/selected_mxl_path_{context}.txt", "w", encoding="utf-8") as f:
              f.write(best["path"])
          with open(f"/tmp/work/selected_mxl_member_{context}.txt", "w", encoding="utf-8") as f:
              f.write(best["member"] or "")
          if context == "full":
              with open("/tmp/work/selected_mxl_path.txt", "w", encoding="utf-8") as f:
                  f.write(best["path"])
              with open("/tmp/work/selected_mxl_member.txt", "w", encoding="utf-8") as f:
                  f.write(best["member"] or "")

          if best["parts"] <= 0 or best["measures"] <= 0:
              print(
                  "MXL_CHECK_FAIL "
                  f"context={context} reason=parts_or_measures_zero path={best['path']} "
                  f"member={best['member']} parts={best['parts']} measures={best['measures']}"
              )
              raise SystemExit(1)
          PY
          }

          probe_omr_version "${AUDIVERIS_IMAGE}"

          run_omr_smoke "${AUDIVERIS_IMAGE}" audiveris_smoke
          if ! check_mxl "/tmp/work/audiveris_smoke" "smoke"; then
            echo "ERROR: smoke run did not produce usable MusicXML (parts/measures > 0 required)."
            exit 1
          fi
          echo "SMOKE_SELECTED_PATH=$(cat /tmp/work/selected_mxl_path_smoke.txt)"
          echo "SMOKE_SELECTED_MEMBER=$(cat /tmp/work/selected_mxl_member_smoke.txt)"

          run_omr "${AUDIVERIS_IMAGE}" audiveris_out_try1
          SELECTED_OUT="/tmp/work/audiveris_out_try1"
          if ! check_mxl "$SELECTED_OUT" "full"; then
            echo "MusicXML export has no parts/measures after successful startup."
            echo "Failing fast in xml-strict mode (no fallback image retry)."
            exit 1
          fi

          AUDI_SELECTED_OUT="${SELECTED_OUT}"
          MXL_MEMBER_OVERRIDE="$(cat /tmp/work/selected_mxl_member.txt)"
          MXL_PATH_OVERRIDE="$(cat /tmp/work/selected_mxl_path.txt)"
          echo "AUDI_SELECTED_OUT=${AUDI_SELECTED_OUT}" >> "$GITHUB_ENV"
          echo "MXL_MEMBER_OVERRIDE=${MXL_MEMBER_OVERRIDE}" >> "$GITHUB_ENV"
          echo "MXL_PATH_OVERRIDE=${MXL_PATH_OVERRIDE}" >> "$GITHUB_ENV"
          echo "AUDI_SELECTED_OUT=${AUDI_SELECTED_OUT}"
          echo "MXL_PATH_OVERRIDE=${MXL_PATH_OVERRIDE}"
          echo "MXL_MEMBER_OVERRIDE=${MXL_MEMBER_OVERRIDE}"

          echo "Audiveris outputs:"
          find "${AUDI_SELECTED_OUT}" -maxdepth 4 -type f -print || true
          echo "Smoke outputs:"
          find /tmp/work/audiveris_smoke -maxdepth 4 -type f -print || true
          echo "MusicXML candidates:"
          ls -lh "${AUDI_SELECTED_OUT}/input" || true
          find "${AUDI_SELECTED_OUT}" -maxdepth 4 -type f \( -name "*.mxl" -o -name "*.musicxml" -o -name "*.xml" \) -print || true

      - name: MusicXML debug (member list + head)
        run: |
          set -euo pipefail
          MXL="${MXL_PATH_OVERRIDE:-}"
          MEMBER="${MXL_MEMBER_OVERRIDE:-}"
          if [[ -z "$MXL" && -f /tmp/work/selected_mxl_path.txt ]]; then
            MXL="$(cat /tmp/work/selected_mxl_path.txt)"
          fi
          if [[ -z "$MEMBER" && -f /tmp/work/selected_mxl_member.txt ]]; then
            MEMBER="$(cat /tmp/work/selected_mxl_member.txt)"
          fi
          if [[ ! -f "$MXL" ]]; then
            echo "No MXL at $MXL"
            find "${AUDI_SELECTED_OUT:-/tmp/work}" -maxdepth 4 -type f -print || true
            exit 0
          fi
          echo "=== MXL member list (xml/musicxml only) ==="
          unzip -l "$MXL" | grep -E '\.xml$|\.musicxml$' || true
          echo "=== Head of selected XML member ==="
          if [[ -n "$MEMBER" ]]; then
            echo "Selected member: $MEMBER"
            unzip -p "$MXL" "$MEMBER" | head -n 200 || true
          else
            echo "No selected member found, printing first xml member."
            FIRST_MEMBER="$(unzip -Z1 "$MXL" | grep -E '\.xml$|\.musicxml$' | head -n 1 || true)"
            if [[ -n "$FIRST_MEMBER" ]]; then
              echo "First member: $FIRST_MEMBER"
              unzip -p "$MXL" "$FIRST_MEMBER" | head -n 200 || true
            fi
          fi

      - name: Validate OMR and print archive debug
        run: |
          set -euo pipefail
          OMR="${AUDI_SELECTED_OUT}/input/input.omr"
          if [[ ! -f "$OMR" ]]; then
            echo "ERROR: missing $OMR"
            find "${AUDI_SELECTED_OUT}" -maxdepth 4 -type f -print || true
            exit 1
          fi

          echo "Top of OMR archive listing:"
          unzip -l "$OMR" | sed -n '1,220p'

          echo "Audiveris logs (tail):"
          for f in "${AUDI_SELECTED_OUT}"/input/*.log; do
            [[ -f "$f" ]] || continue
            echo "--- $f (last 120 lines) ---"
            tail -n 120 "$f" || true
          done

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.10"

      - name: Install Python dependencies
        run: |
          set -euo pipefail
          python -m pip install --upgrade pip
          pip install opencv-python==4.12.0.88 pymupdf==1.20.0 numpy lxml==5.3.0

      - name: Build page-split XML manifest (optional strict mode)
        if: ${{ inputs.enable_page_split_manifest }}
        env:
          AUDIVERIS_IMAGE: "${{ inputs.audiveris_image }}"
        run: |
          set -euo pipefail
          mkdir -p /tmp/work/pages /tmp/work/audiveris_pages /tmp/work/page_logs

          python - << 'PY'
          import fitz
          import os

          src = "/tmp/work/input.pdf"
          out_dir = "/tmp/work/pages"
          os.makedirs(out_dir, exist_ok=True)

          doc = fitz.open(src)
          for idx in range(doc.page_count):
              single = fitz.open()
              single.insert_pdf(doc, from_page=idx, to_page=idx)
              out_path = os.path.join(out_dir, f"page_{idx+1:04d}.pdf")
              single.save(out_path)
              single.close()
          doc.close()
          print(f"PAGE_SPLIT total_pages={len([p for p in os.listdir(out_dir) if p.endswith('.pdf')])}")
          PY

          run_page_omr() {
            local image="$1"
            local page_num="$2"
            docker run --rm \
              --user "$(id -u):$(id -g)" \
              -v /tmp/work:/work \
              -e PAGE_NUM="${page_num}" \
              -e AUDI_IMAGE="${image}" \
              -e AUDI_OUT_DIR="/work/audiveris_pages/page_${page_num}" \
              -e HOME="/work" \
              -e XDG_CACHE_HOME="/work/.cache" \
              -e XDG_CONFIG_HOME="/work/.config" \
              -e JAVA_TOOL_OPTIONS="-Duser.home=/work -Djava.io.tmpdir=/work/tmp" \
              "${image}" \
              sh -c 'set -e; AUDI_BIN="/audiveris-extract/bin/Audiveris"; if [ -x /audiveris/bin/Audiveris ]; then AUDI_BIN="/audiveris/bin/Audiveris"; fi; if [ -x /opt/audiveris/bin/Audiveris ]; then AUDI_BIN="/opt/audiveris/bin/Audiveris"; fi; mkdir -p /work/.cache /work/.config /work/tmp "${AUDI_OUT_DIR}"; "$AUDI_BIN" -batch -export -output "${AUDI_OUT_DIR}" "/work/pages/page_${PAGE_NUM}.pdf"'
          }

          for page_pdf in /tmp/work/pages/page_*.pdf; do
            [[ -f "${page_pdf}" ]] || continue
            page_num="$(basename "${page_pdf}" | sed -E 's/^page_([0-9]{4})\.pdf$/\1/')"
            log_path="/tmp/work/page_logs/page_${page_num}.log"
            if run_page_omr "${AUDIVERIS_IMAGE}" "${page_num}" >"${log_path}" 2>&1; then
              exit_code=0
            else
              exit_code=$?
            fi
            echo "PAGE_XML_RUN page=$((10#${page_num})) image=${AUDIVERIS_IMAGE} exit_code=${exit_code} log=${log_path}"
          done

          python - << 'PY'
          import glob
          import json
          import os
          import re
          import zipfile
          import xml.etree.ElementTree as ET

          MANIFEST_PATH = "/tmp/work/mxl_page_manifest.json"

          def local(tag):
              if isinstance(tag, str):
                  return tag.split("}", 1)[-1] if "}" in tag else tag
              return str(tag)

          def iter_named(root, name):
              out = []
              for el in root.iter():
                  tag = getattr(el, "tag", None)
                  if isinstance(tag, str) and local(tag) == name:
                      out.append(el)
              return out

          def children_named(el, name):
              return [c for c in list(el) if local(c.tag) == name]

          def truthy_attr(v):
              if not v:
                  return False
              return str(v).strip().lower() in ("1", "true", "yes")

          def parse_xml_member(raw):
              try:
                  root = ET.fromstring(raw)
              except Exception:
                  parts = len(re.findall(br"<\s*part(\s|>)", raw, flags=re.IGNORECASE))
                  measures = len(re.findall(br"<\s*measure(\s|>)", raw, flags=re.IGNORECASE))
                  return {
                      "parse": "tagscan",
                      "root": "unknown",
                      "parts": parts,
                      "measures": measures,
                      "system_starts": [],
                  }

              parts = len(iter_named(root, "part"))
              measures = len(iter_named(root, "measure"))
              starts = []

              if local(root.tag) == "score-partwise":
                  score_parts = children_named(root, "part")
                  if score_parts:
                      ms = children_named(score_parts[0], "measure")
                  else:
                      ms = []
                  if ms:
                      starts.append((ms[0].get("number") or "").strip() or "1")
                      for i, m in enumerate(ms[1:], start=2):
                          label = (m.get("number") or "").strip() or str(i)
                          is_new_system = False
                          has_system_layout = False
                          for pr in children_named(m, "print"):
                              is_new_system = is_new_system or truthy_attr(pr.get("new-system")) or truthy_attr(pr.get("new-page"))
                              if children_named(pr, "system-layout"):
                                  has_system_layout = True
                          if is_new_system or has_system_layout:
                              starts.append(label)
              return {
                  "parse": "stdlib",
                  "root": local(root.tag),
                  "parts": parts,
                  "measures": measures,
                  "system_starts": starts,
              }

          def score_mxl(mxl_path):
              best = None
              try:
                  with zipfile.ZipFile(mxl_path, "r") as z:
                      for name in z.namelist():
                          lname = name.lower()
                          if name.startswith("META-INF/"):
                              continue
                          if not (lname.endswith(".xml") or lname.endswith(".musicxml")):
                              continue
                          try:
                              raw = z.read(name)
                          except Exception:
                              continue
                          scored = parse_xml_member(raw)
                          cand = {"member": name, **scored}
                          if best is None or (cand["measures"], cand["parts"]) > (best["measures"], best["parts"]):
                              best = cand
              except Exception as exc:
                  return {
                      "path": mxl_path,
                      "member": None,
                      "parse": "zip_error",
                      "root": "zip_error",
                      "parts": 0,
                      "measures": 0,
                      "system_starts": [],
                      "error": str(exc),
                  }
              if best is None:
                  return {
                      "path": mxl_path,
                      "member": None,
                      "parse": "none",
                      "root": "no_xml_members",
                      "parts": 0,
                      "measures": 0,
                      "system_starts": [],
                      "error": None,
                  }
              return {"path": mxl_path, **best, "error": None}

          page_pdfs = sorted(glob.glob("/tmp/work/pages/page_*.pdf"))
          entries = []
          missing = 0

          for page_pdf in page_pdfs:
              page_num = int(re.search(r"page_(\d{4})\.pdf$", page_pdf).group(1))
              page_idx = page_num - 1
              out_dir = f"/tmp/work/audiveris_pages/page_{page_num:04d}"
              candidates = sorted(glob.glob(os.path.join(out_dir, "**", "*.mxl"), recursive=True))
              scored = [score_mxl(path) for path in candidates]
              best = None
              if scored:
                  best = max(scored, key=lambda row: (row["measures"], row["parts"], row["path"], row.get("member") or ""))

              if best and best["parts"] > 0 and best["measures"] > 0 and best.get("system_starts"):
                  entry = {
                      "page_index": page_idx,
                      "page_number": page_num,
                      "status": "ok",
                      "error": None,
                      "mxl_path": best["path"],
                      "mxl_member": best.get("member"),
                      "parts_count": int(best["parts"]),
                      "measures_count": int(best["measures"]),
                      "system_starts": list(best.get("system_starts") or []),
                      "selection_source": "per_page_split",
                      "selection_reason": "per_page_xml_usable",
                      "confidence_tier": "high",
                      "low_confidence_used": False,
                      "retry_attempted": False,
                      "retry_profile": "none",
                  }
                  print(
                      "PAGE_XML_SELECTED "
                      f"page={page_num} path={entry['mxl_path']} member={entry['mxl_member']} "
                      f"parts={entry['parts_count']} measures={entry['measures_count']} "
                      f"systems={len(entry['system_starts'])} source={entry['selection_source']}"
                  )
              else:
                  reason = "no_mxl_candidates"
                  if best:
                      if best["parts"] <= 0 or best["measures"] <= 0:
                          reason = "parts_or_measures_zero"
                      elif not best.get("system_starts"):
                          reason = "system_starts_missing"
                  entry = {
                      "page_index": page_idx,
                      "page_number": page_num,
                      "status": "missing",
                      "error": reason,
                      "mxl_path": best["path"] if best else None,
                      "mxl_member": best.get("member") if best else None,
                      "parts_count": int(best["parts"]) if best else 0,
                      "measures_count": int(best["measures"]) if best else 0,
                      "system_starts": list(best.get("system_starts") or []) if best else [],
                      "selection_source": "none",
                      "selection_reason": reason,
                      "confidence_tier": "none",
                      "low_confidence_used": False,
                      "retry_attempted": False,
                      "retry_profile": "none",
                  }
                  missing += 1
                  print(
                      "PAGE_XML_UNRESOLVED "
                      f"page={page_num} reason={reason} path={entry['mxl_path']} "
                      f"parts={entry['parts_count']} measures={entry['measures_count']}"
                  )
              entries.append(entry)

          payload = {
              "manifest_version": "page-split-v1",
              "entries": entries,
              "total_pages": len(entries),
              "missing": missing,
          }
          with open(MANIFEST_PATH, "w", encoding="utf-8") as f:
              json.dump(payload, f, indent=2)

          print(
              f"MXL_PAGE_MANIFEST path={MANIFEST_PATH} entries={len(entries)} missing={missing}"
          )
          PY

          echo "MXL_PAGE_MANIFEST_PATH=/tmp/work/mxl_page_manifest.json" >> "$GITHUB_ENV"

      - name: Annotate PDF (guides + measure labels) with verbose debug
        env:
          DEBUG_GUIDES: "0"
          ENABLE_MEASURE_LABELS: "1"
          MEASURE_LABEL_MODE: "staff_start"
          MEASURE_SOURCE_POLICY: "mxl_strict"
          MXL_PARSER_POLICY: "auto"
          MXL_SANITIZE_PREFIXES: "1"
          MXL_PATH_OVERRIDE: "${{ env.MXL_PATH_OVERRIDE }}"
          MXL_MEMBER_OVERRIDE: "${{ env.MXL_MEMBER_OVERRIDE }}"
          MXL_PAGE_MANIFEST_PATH: "${{ env.MXL_PAGE_MANIFEST_PATH }}"
          DEBUG_MEASURE_LABELS: "1"
          DEBUG_MEASURE_MARKERS: "0"
          DEBUG_SENTINEL_TEXT: "1"
          MEASURE_MAPPING_DEBUG_PATH: "/tmp/work/measure_mapping_debug.json"
        run: |
          set -euo pipefail
          echo "PARSER_SHA=$(git rev-parse --short HEAD)"
          python - << 'PY'
          p = "parser-api/annotate_guides_from_omr.py"
          text = open(p, "r", encoding="utf-8").read()
          markers = [
              "mxl_movement",
              "mapping_mode",
              "labels_to_draw_count",
              "DEBUG_SENTINEL_TEXT",
              "MXL_PAGE_MANIFEST_PATH",
          ]
          for m in markers:
              print(f"PARSER_MARKER {m} present={m in text}")
          PY
          python -u parser-api/annotate_guides_from_omr.py \
            /tmp/work/input.pdf \
            "${AUDI_SELECTED_OUT}/input/input.omr" \
            /tmp/work/annotated.pdf
          ls -lh /tmp/work/annotated.pdf

      - name: Sanity-check output PDF
        run: |
          set -euo pipefail
          python - << 'PY'
          import fitz

          in_doc = fitz.open('/tmp/work/input.pdf')
          out_doc = fitz.open('/tmp/work/annotated.pdf')
          print('input_pages=', in_doc.page_count)
          print('output_pages=', out_doc.page_count)
          if in_doc.page_count != out_doc.page_count:
            raise SystemExit('ERROR: output page count mismatch')
          PY

      - name: Mapping debug summary
        run: |
          set -euo pipefail
          python - << 'PY'
          import json

          p = "/tmp/work/measure_mapping_debug.json"
          d = json.load(open(p, "r", encoding="utf-8"))
          print("SUMMARY mxl_path=", d.get("mxl_path"))
          print("SUMMARY mxl_paths=", d.get("mxl_paths"))
          movements = d.get("mxl_movements") or []
          for i, m in enumerate(movements, start=1):
              print(
                  f"SUMMARY movement#{i} path={m.get('mxl_path')} "
                  f"status={m.get('mxl_parse_status')} pages={m.get('mxl_pages')} "
                  f"member={m.get('mxl_member_path')} "
                  f"source_sheets={m.get('mxl_source_sheet_numbers')}"
              )

          pages = d.get("pages") or []
          manifest_path = d.get("mxl_page_manifest_path")
          if manifest_path:
              manifest_summary = d.get("mxl_page_manifest_summary") or {}
              print(f"SUMMARY manifest_path={manifest_path}")
              print(
                  "SUMMARY manifest "
                  f"entries={manifest_summary.get('entries')} "
                  f"missing={manifest_summary.get('missing')} "
                  f"status={manifest_summary.get('status')}"
              )
          strict_xml_pages_ok = 0
          total_pages = len(pages)
          strict_xml_missing = []
          for pg in pages:
              source = pg.get("staff_start_source")
              status = pg.get("mapping_status")
              mode = pg.get("mapping_mode")
              draw_attempted = bool(pg.get("draw_attempted"))
              labels_to_draw = int(pg.get("labels_to_draw_count") or 0)
              labels_drawn = int(pg.get("labels_drawn") or 0)
              labels_in_bounds = int(pg.get("labels_in_bounds") or 0)

              if source != "mxl":
                  if mode == "missing":
                      failure_class = "NO_XML_COVERAGE"
                  elif status == "error":
                      failure_class = "MAP_EMPTY"
                  else:
                      failure_class = "MAP_NOT_MXL"
              elif labels_to_draw == 0:
                  failure_class = "DRAW_EMPTY"
              elif labels_drawn == 0:
                  failure_class = "DRAW_ZERO"
              elif labels_in_bounds == 0:
                  failure_class = "DRAW_OFFPAGE"
              else:
                  failure_class = "DRAW_OK"

              if source == "mxl":
                  strict_xml_pages_ok += 1
              else:
                  strict_xml_missing.append(
                      (
                          int(pg.get("page_index", 0)) + 1,
                          str(pg.get("mapping_reason")),
                          str(status),
                          str(mode),
                      )
                  )

              print(
                  f"SUMMARY page={pg.get('page_index', 0)+1} "
                  f"source={source} "
                  f"status={status} "
                  f"reason={pg.get('mapping_reason')} "
                  f"mode={mode} "
                  f"selection_source={pg.get('xml_selection_source')} "
                  f"confidence={pg.get('xml_confidence_tier')} "
                  f"mxl_sys={len(pg.get('mxl_page_system_starts') or [])} "
                  f"omr_sys={len(pg.get('omr_system_staff_counts') or [])} "
                  f"assigned={len(pg.get('assigned_labels') or [])} "
                  f"candidates={pg.get('staff_start_candidate_count')} "
                  f"draw_attempted={draw_attempted} "
                  f"labels_to_draw={labels_to_draw} "
                  f"labels_drawn={labels_drawn} "
                  f"labels_in_bounds={labels_in_bounds} "
                  f"failure_class={failure_class}"
              )

          print(f"SUMMARY strict_xml_pages_ok={strict_xml_pages_ok}/{total_pages}")
          if strict_xml_pages_ok != total_pages:
              for page_no, reason, status, mode in strict_xml_missing:
                  print(
                      "SUMMARY strict_xml_missing "
                      f"page={page_no} reason={reason} status={status} mode={mode}"
                  )
              raise SystemExit(
                  f"ERROR: strict XML coverage failed strict_xml_pages_ok={strict_xml_pages_ok}/{total_pages}"
              )
          PY

      - name: Bundle debug artifacts
        if: always()
        run: |
          set -euo pipefail
          rm -f /tmp/work/omr_debug_bundle.tar.gz
          tar -czf /tmp/work/omr_debug_bundle.tar.gz \
            /tmp/work/audi_help_probe.txt \
            /tmp/work/audi_help.txt \
            /tmp/work/selected_mxl_path*.txt \
            /tmp/work/selected_mxl_member*.txt \
            /tmp/work/audiveris_smoke \
            /tmp/work/audiveris_out_try1 \
            /tmp/work/pages \
            /tmp/work/page_logs \
            /tmp/work/audiveris_pages \
            /tmp/work/mxl_page_manifest.json \
            /tmp/work/measure_mapping_debug.json \
            2>/dev/null || true
          if [[ -f /tmp/work/omr_debug_bundle.tar.gz ]]; then
            ls -lh /tmp/work/omr_debug_bundle.tar.gz
          fi

      - name: Upload outputs and debug artifacts
        if: always()
        run: |
          set -euo pipefail
          if [[ -f /tmp/work/annotated.pdf ]]; then
            gsutil cp /tmp/work/annotated.pdf "${OUTPUT_PREFIX}/annotated.pdf"
            echo "uploaded_latest=${OUTPUT_PREFIX}/annotated.pdf"
          else
            echo "WARN: /tmp/work/annotated.pdf not found"
          fi
          if [[ -f /tmp/work/measure_mapping_debug.json ]]; then
            gsutil cp /tmp/work/measure_mapping_debug.json "${OUTPUT_PREFIX}/measure_mapping_debug.json"
            echo "uploaded_mapping_debug=${OUTPUT_PREFIX}/measure_mapping_debug.json"
          else
            echo "WARN: /tmp/work/measure_mapping_debug.json not found"
          fi
          if [[ -f /tmp/work/mxl_page_manifest.json ]]; then
            gsutil cp /tmp/work/mxl_page_manifest.json "${OUTPUT_PREFIX}/mxl_page_manifest.json"
            echo "uploaded_manifest=${OUTPUT_PREFIX}/mxl_page_manifest.json"
          else
            echo "WARN: /tmp/work/mxl_page_manifest.json not found"
          fi
          if [[ -f /tmp/work/omr_debug_bundle.tar.gz ]]; then
            gsutil cp /tmp/work/omr_debug_bundle.tar.gz "${OUTPUT_PREFIX}/omr_debug_bundle.tar.gz"
            echo "uploaded_debug_bundle=${OUTPUT_PREFIX}/omr_debug_bundle.tar.gz"
          else
            echo "WARN: /tmp/work/omr_debug_bundle.tar.gz not found"
          fi

          echo "Upload complete"
