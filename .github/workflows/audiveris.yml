name: Audiveris OMR + Measure Label Debug

on:
  workflow_dispatch:
    inputs:
      pdf_gcs_uri:
        description: "GCS URI to input PDF (gs://music-omr-bucket-777135743132/input/test.pdf)"
        required: true
        type: string

jobs:
  pipeline:
    runs-on: ubuntu-latest
    env:
      OUTPUT_PREFIX: "gs://music-omr-bucket-777135743132/output"

    permissions:
      contents: read
      id-token: write

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT_EMAIL }}
          create_credentials_file: true

      - name: Set up Google Cloud SDK (apt)
        run: |
          set -euo pipefail
          if command -v gcloud >/dev/null 2>&1; then
            gcloud --version
            exit 0
          fi
          sudo apt-get update -y
          sudo apt-get install -y apt-transport-https ca-certificates gnupg curl
          curl -fsSL https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo gpg --dearmor -o /usr/share/keyrings/cloud.google.gpg
          echo "deb [signed-by=/usr/share/keyrings/cloud.google.gpg] https://packages.cloud.google.com/apt cloud-sdk main" | sudo tee /etc/apt/sources.list.d/google-cloud-sdk.list
          sudo apt-get update -y
          sudo apt-get install -y google-cloud-cli
          gcloud --version

      - name: Configure gcloud auth for gsutil
        run: |
          set -euo pipefail
          if [[ -z "${GOOGLE_APPLICATION_CREDENTIALS:-}" ]]; then
            echo "ERROR: GOOGLE_APPLICATION_CREDENTIALS not set"
            exit 1
          fi
          echo "GOOGLE_APPLICATION_CREDENTIALS=${GOOGLE_APPLICATION_CREDENTIALS}"
          echo "CLOUDSDK_AUTH_CREDENTIAL_FILE_OVERRIDE=${GOOGLE_APPLICATION_CREDENTIALS}" >> "$GITHUB_ENV"
          gcloud auth login --cred-file="${GOOGLE_APPLICATION_CREDENTIALS}"
          gcloud auth list

      - name: Show run context
        run: |
          set -euo pipefail
          echo "repo: $GITHUB_REPOSITORY"
          echo "sha:  $GITHUB_SHA"
          echo "pdf_gcs_uri: ${{ inputs.pdf_gcs_uri }}"
          echo "output_prefix: ${OUTPUT_PREFIX}"

      - name: Download input PDF
        run: |
          set -euo pipefail
          mkdir -p /tmp/work
          gsutil cp "${{ inputs.pdf_gcs_uri }}" /tmp/work/input.pdf
          ls -lh /tmp/work/input.pdf

      - name: Run Audiveris OMR
        run: |
          set -euo pipefail
          mkdir -p /tmp/work
          echo "WORKFLOW_SIGNATURE=xml-select-v4"
          echo "WORKFLOW_SHA=${GITHUB_SHA}"

          run_omr() {
            local image="$1"
            local out_dir_name="$2"
            docker run --rm \
              --user "$(id -u):$(id -g)" \
              -v /tmp/work:/work \
              -e AUDI_IMAGE="${image}" \
              -e AUDI_OUT_DIR="/work/${out_dir_name}" \
              "$image" \
              sh -c 'AUDI_BIN="/audiveris-extract/bin/Audiveris"; if [ -x /audiveris/bin/Audiveris ]; then AUDI_BIN="/audiveris/bin/Audiveris"; fi; echo "AUDIVERIS_ATTEMPT image=${AUDI_IMAGE} out_dir=${AUDI_OUT_DIR} bin=${AUDI_BIN}"; "$AUDI_BIN" -batch -export -output "$AUDI_OUT_DIR" /work/input.pdf' || true
          }

          check_mxl() {
            local out_dir="$1"
            python - "$out_dir" <<'PY'
          import glob
          import os
          import re
          import sys
          import zipfile
          import xml.etree.ElementTree as ET

          try:
              from lxml import etree as LET  # type: ignore
          except Exception:
              LET = None


          def local(tag):
              if isinstance(tag, str):
                  return tag.split("}", 1)[-1] if "}" in tag else tag
              return str(tag)


          def count_by_tagscan(raw: bytes):
              parts = len(re.findall(br"<\s*part(\s|>)", raw, flags=re.IGNORECASE))
              measures = len(re.findall(br"<\s*measure(\s|>)", raw, flags=re.IGNORECASE))
              return parts, measures


          def score_xml_member(raw: bytes):
              try:
                  root = ET.fromstring(raw)
                  parts = sum(1 for el in root.iter() if local(el.tag) == "part")
                  measures = sum(1 for el in root.iter() if local(el.tag) == "measure")
                  return {
                      "parse": "stdlib",
                      "root": local(root.tag),
                      "parts": parts,
                      "measures": measures,
                  }
              except Exception:
                  pass

              if LET is not None:
                  try:
                      parser = LET.XMLParser(recover=True, huge_tree=True)
                      root = LET.fromstring(raw, parser=parser)
                      root_name = local(root.tag) if root is not None else "unknown"
                      parts = len(root.xpath('//*[local-name()="part"]')) if root is not None else 0
                      measures = len(root.xpath('//*[local-name()="measure"]')) if root is not None else 0
                      return {
                          "parse": "lxml_recover",
                          "root": root_name,
                          "parts": parts,
                          "measures": measures,
                      }
                  except Exception:
                      pass

              parts, measures = count_by_tagscan(raw)
              return {
                  "parse": "tagscan",
                  "root": "unknown",
                  "parts": parts,
                  "measures": measures,
              }


          def score_mxl(mxl_path):
              best_member = None
              try:
                  with zipfile.ZipFile(mxl_path, "r") as z:
                      for name in z.namelist():
                          if name.startswith("META-INF/"):
                              continue
                          if not (name.lower().endswith(".xml") or name.lower().endswith(".musicxml")):
                              continue
                          try:
                              raw = z.read(name)
                          except Exception:
                              continue
                          scored = score_xml_member(raw)
                          cand = {"member": name, **scored}
                          if best_member is None or (cand["measures"], cand["parts"]) > (
                              best_member["measures"],
                              best_member["parts"],
                          ):
                              best_member = cand
              except Exception as exc:
                  return {
                      "path": mxl_path,
                      "member": None,
                      "parse": "zip_error",
                      "root": "zip_error",
                      "parts": 0,
                      "measures": 0,
                      "error": str(exc),
                  }

              if best_member is None:
                  return {
                      "path": mxl_path,
                      "member": None,
                      "parse": "none",
                      "root": "no_xml_members",
                      "parts": 0,
                      "measures": 0,
                      "error": None,
                  }

              return {"path": mxl_path, **best_member, "error": None}


          out_dir = sys.argv[1]
          mxl_candidates = sorted(glob.glob(os.path.join(out_dir, "input", "*.mxl")))
          if not mxl_candidates:
              print(f"MXL_CHECK: no .mxl found under {out_dir}/input")
              raise SystemExit(2)

          scored = [score_mxl(path) for path in mxl_candidates]
          for row in scored:
              err = f" error={row['error']}" if row.get("error") else ""
              print(
                  "MXL_CANDIDATE "
                  f"path={row['path']} member={row['member']} parse={row['parse']} "
                  f"root={row['root']} parts={row['parts']} measures={row['measures']}{err}"
              )

          best = max(scored, key=lambda r: (r["measures"], r["parts"]))
          print(
              "MXL_SELECTED "
              f"path={best['path']} member={best['member']} parse={best['parse']} "
              f"parts={best['parts']} measures={best['measures']}"
          )

          with open("/tmp/work/selected_mxl_path.txt", "w", encoding="utf-8") as f:
              f.write(best["path"])
          with open("/tmp/work/selected_mxl_member.txt", "w", encoding="utf-8") as f:
              f.write(best["member"] or "")

          if best["parts"] <= 0 or best["measures"] <= 0:
              raise SystemExit(1)
          PY
          }

          run_omr toprock/audiveris:latest audiveris_out_try1
          SELECTED_OUT="/tmp/work/audiveris_out_try1"
          if ! check_mxl "$SELECTED_OUT"; then
            echo "MusicXML export has no parts/measures. Retrying with full Audiveris image."
            run_omr audiveris/audiveris audiveris_out_try2
            SELECTED_OUT="/tmp/work/audiveris_out_try2"
            check_mxl "$SELECTED_OUT"
          fi

          AUDI_SELECTED_OUT="${SELECTED_OUT}"
          MXL_MEMBER_OVERRIDE="$(cat /tmp/work/selected_mxl_member.txt)"
          MXL_PATH_OVERRIDE="$(cat /tmp/work/selected_mxl_path.txt)"
          echo "AUDI_SELECTED_OUT=${AUDI_SELECTED_OUT}" >> "$GITHUB_ENV"
          echo "MXL_MEMBER_OVERRIDE=${MXL_MEMBER_OVERRIDE}" >> "$GITHUB_ENV"
          echo "MXL_PATH_OVERRIDE=${MXL_PATH_OVERRIDE}" >> "$GITHUB_ENV"
          echo "AUDI_SELECTED_OUT=${AUDI_SELECTED_OUT}"
          echo "MXL_PATH_OVERRIDE=${MXL_PATH_OVERRIDE}"
          echo "MXL_MEMBER_OVERRIDE=${MXL_MEMBER_OVERRIDE}"

          echo "Audiveris outputs:"
          find "${AUDI_SELECTED_OUT}" -maxdepth 4 -type f -print || true
          echo "MusicXML candidates:"
          ls -lh "${AUDI_SELECTED_OUT}/input" || true
          find "${AUDI_SELECTED_OUT}" -maxdepth 4 -type f \( -name "*.mxl" -o -name "*.musicxml" -o -name "*.xml" \) -print || true

      - name: MusicXML debug (member list + head)
        run: |
          set -euo pipefail
          MXL="${MXL_PATH_OVERRIDE:-}"
          MEMBER="${MXL_MEMBER_OVERRIDE:-}"
          if [[ -z "$MXL" && -f /tmp/work/selected_mxl_path.txt ]]; then
            MXL="$(cat /tmp/work/selected_mxl_path.txt)"
          fi
          if [[ -z "$MEMBER" && -f /tmp/work/selected_mxl_member.txt ]]; then
            MEMBER="$(cat /tmp/work/selected_mxl_member.txt)"
          fi
          if [[ ! -f "$MXL" ]]; then
            echo "No MXL at $MXL"
            find "${AUDI_SELECTED_OUT:-/tmp/work}" -maxdepth 4 -type f -print || true
            exit 0
          fi
          echo "=== MXL member list (xml/musicxml only) ==="
          unzip -l "$MXL" | grep -E '\.xml$|\.musicxml$' || true
          echo "=== Head of selected XML member ==="
          if [[ -n "$MEMBER" ]]; then
            echo "Selected member: $MEMBER"
            unzip -p "$MXL" "$MEMBER" | head -n 200 || true
          else
            echo "No selected member found, printing first xml member."
            FIRST_MEMBER="$(unzip -Z1 "$MXL" | grep -E '\.xml$|\.musicxml$' | head -n 1 || true)"
            if [[ -n "$FIRST_MEMBER" ]]; then
              echo "First member: $FIRST_MEMBER"
              unzip -p "$MXL" "$FIRST_MEMBER" | head -n 200 || true
            fi
          fi

      - name: Validate OMR and print archive debug
        run: |
          set -euo pipefail
          OMR="${AUDI_SELECTED_OUT}/input/input.omr"
          if [[ ! -f "$OMR" ]]; then
            echo "ERROR: missing $OMR"
            find "${AUDI_SELECTED_OUT}" -maxdepth 4 -type f -print || true
            exit 1
          fi

          echo "Top of OMR archive listing:"
          unzip -l "$OMR" | sed -n '1,220p'

          echo "Audiveris logs (tail):"
          for f in "${AUDI_SELECTED_OUT}"/input/*.log; do
            [[ -f "$f" ]] || continue
            echo "--- $f (last 120 lines) ---"
            tail -n 120 "$f" || true
          done

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.10"

      - name: Install Python dependencies
        run: |
          set -euo pipefail
          python -m pip install --upgrade pip
          pip install opencv-python==4.12.0.88 pymupdf==1.20.0 numpy lxml==5.3.0

      - name: Annotate PDF (guides + measure labels) with verbose debug
        env:
          DEBUG_GUIDES: "0"
          ENABLE_MEASURE_LABELS: "1"
          MEASURE_LABEL_MODE: "staff_start"
          MEASURE_SOURCE_POLICY: "mxl_strict"
          MXL_PARSER_POLICY: "auto"
          MXL_SANITIZE_PREFIXES: "1"
          MXL_PATH_OVERRIDE: "${{ env.MXL_PATH_OVERRIDE }}"
          DEBUG_MEASURE_LABELS: "1"
          DEBUG_MEASURE_MARKERS: "0"
          MEASURE_MAPPING_DEBUG_PATH: "/tmp/work/measure_mapping_debug.json"
        run: |
          set -euo pipefail
          python -u parser-api/annotate_guides_from_omr.py \
            /tmp/work/input.pdf \
            "${AUDI_SELECTED_OUT}/input/input.omr" \
            /tmp/work/annotated.pdf
          ls -lh /tmp/work/annotated.pdf

      - name: Sanity-check output PDF
        run: |
          set -euo pipefail
          python - << 'PY'
          import fitz

          in_doc = fitz.open('/tmp/work/input.pdf')
          out_doc = fitz.open('/tmp/work/annotated.pdf')
          print('input_pages=', in_doc.page_count)
          print('output_pages=', out_doc.page_count)
          if in_doc.page_count != out_doc.page_count:
            raise SystemExit('ERROR: output page count mismatch')
          PY

      - name: Upload outputs and debug artifacts
        run: |
          set -euo pipefail
          gsutil cp /tmp/work/annotated.pdf "${OUTPUT_PREFIX}/annotated.pdf"
          gsutil cp /tmp/work/measure_mapping_debug.json "${OUTPUT_PREFIX}/measure_mapping_debug.json"
          echo "uploaded_latest=${OUTPUT_PREFIX}/annotated.pdf"
          echo "uploaded_mapping_debug=${OUTPUT_PREFIX}/measure_mapping_debug.json"

          echo "Upload complete"
